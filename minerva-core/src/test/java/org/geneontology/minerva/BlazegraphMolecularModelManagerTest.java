package org.geneontology.minerva;

import static org.junit.Assert.*;

import java.io.File;
import java.io.IOException;

import org.apache.commons.io.FileUtils;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.rdf.model.Statement;
import org.apache.jena.rdf.model.StmtIterator;
import org.junit.Test;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;

import owltools.OWLToolsTestBasics;
import owltools.graph.OWLGraphWrapper;
import owltools.io.CatalogXmlIRIMapper;
import owltools.io.ParserWrapper;

public class BlazegraphMolecularModelManagerTest extends OWLToolsTestBasics {

	/**
	 * Test whether the revised import function properly digest turtle files. We import a ttl file 
	 * into the model, dump the model into file, and then compare the initial file with dumped ones. 
	 * Check this pull request for more information: https://github.com/geneontology/minerva/pull/144/files 
     *
	 * @throws OWLOntologyCreationException
	 * @throws IOException
	 */
	@SuppressWarnings("rawtypes")
	@Test
	public void testImportDump() throws OWLOntologyCreationException, IOException {
		/* A temporary journal file for Blazegraph storage system */
		String journalPath = "/tmp/journal.jrnl";	
		/* I used the file from one of the turtle file in
		 * https://github.com/geneontology/noctua-models/blob/master/models/0000000300000001.ttl */
		String sourceModelPath = "src/test/resources/dummy-noctua-model.ttl";
		/* It seems that the path generated by dumpAllStoredModels is not properly escaped. */
		String targetModelPath = "/tmp/http:/model.geneontology.org/0000000300000001.ttl";

		/* Delete any temporary files if they already exist */
		File journalFile = new File(journalPath);
		File targetModelFile = new File(journalPath);
		FileUtils.deleteQuietly(journalFile);
		FileUtils.deleteQuietly(targetModelFile);

		final ParserWrapper pw1 = new ParserWrapper();
		pw1.addIRIMapper(new CatalogXmlIRIMapper(new File("src/test/resources/mmg/catalog-v001.xml")));
		OWLGraphWrapper g = pw1.parseToOWLGraph(getResourceIRIString("mmg/basic-tbox-importer.omn"));
		BlazegraphMolecularModelManager m3 = new BlazegraphMolecularModelManager<>(g, "go", journalPath, "/tmp");

		try {
			/* Import the turtle file */
			m3.importModelToDatabase(new File(sourceModelPath));
			/* Dump triples back into files */
			m3.dumpAllStoredModels();

			/* 
			 * Dumped files often have different orders of triples compared with the ones in the original file, 
			 * thus one-by-one comparison is obviously not working here. We therefore leverage Jena's model, i.e.,  
			 * import two files (original and dumped) using Jena and compare them using iterations. 
			 */
			Model sourceModel = ModelFactory.createDefaultModel() ;
			Model targetModel = ModelFactory.createDefaultModel() ;
			sourceModel.read(sourceModelPath);
			targetModel.read(targetModelPath);

			/* Does the dumped file contain all triples? */
			if (compareModels(sourceModel, targetModel) != true)
				fail("Missing statements in target model.");

			/* Does the dumped file contain any extra triples? */
			if (compareModels(targetModel, sourceModel) != true)
				fail("Sprious statements in target model.");

		} catch (Exception e) {
			/* I wonder we can use any loggers in the future for logging exceptions. */
			e.printStackTrace();
			fail();
		}
	}

	/* 
	 * Compare source and target models, i.e. check whether a statement 
	 * in the source model exists the target model as well. 
	 */
	private boolean compareModels (Model sourceModel, Model targetModel) {
		StmtIterator it =  sourceModel.listStatements();
		while (it.hasNext()) {
			Statement stmt = it.next();

			if (targetModel.contains(stmt) != true) {
				
				/* 
				 * Ignore statements that contain anonymous/blank nodes for now.
				 * Blazegraph does not maintain (original) IDs of blank nodes in their storage system
				 * but they often assign different IDs for nodes when triples with such nodes are dumped. 
				 * Not clear whether this is expected behavior or standard.
				 */
				if (stmt.getSubject().isAnon() != true && stmt.getObject().isAnon() != true) {
					System.out.println(stmt);
					return false;
				}
			}
		}

		return true;
	}
}